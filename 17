@Service
public class DirectTopicReaderService {

    private final ConsumerFactory<String, String> consumerFactory;

    public DirectTopicReaderService(ConsumerFactory<String, String> consumerFactory) {
        this.consumerFactory = consumerFactory;
    }

    public List<String> readMessagesFromTopic(String topicName, int messageCount) {
        List<String> messages = new ArrayList<>();
        
        try (Consumer<String, String> consumer = consumerFactory.createConsumer()) {
            // Подписываемся на топик
            consumer.subscribe(Collections.singletonList(topicName));
            
            // Ждем назначения партиций
            consumer.poll(Duration.ofMillis(1000));
            
            // Перемещаемся в начало топика
            consumer.seekToBeginning(consumer.assignment());
            
            // Читаем сообщения
            while (messages.size() < messageCount) {
                ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
                
                if (records.isEmpty()) {
                    break; // Больше нет сообщений
                }
                
                for (ConsumerRecord<String, String> record : records) {
                    if (messages.size() < messageCount) {
                        messages.add(record.value());
                    } else {
                        break;
                    }
                }
            }
        }
        
        return messages;
    }

    public List<String> readLastMessagesFromTopic(String topicName, int messageCount) {
        List<String> allMessages = readAllMessagesFromTopic(topicName);
        
        int fromIndex = Math.max(0, allMessages.size() - messageCount);
        return allMessages.subList(fromIndex, allMessages.size());
    }

    private List<String> readAllMessagesFromTopic(String topicName) {
        List<String> messages = new ArrayList<>();
        
        try (Consumer<String, String> consumer = consumerFactory.createConsumer()) {
            consumer.subscribe(Collections.singletonList(topicName));
            consumer.poll(Duration.ofMillis(1000));
            consumer.seekToBeginning(consumer.assignment());
            
            while (true) {
                ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
                if (records.isEmpty()) {
                    break;
                }
                
                for (ConsumerRecord<String, String> record : records) {
                    messages.add(record.value());
                }
            }
        }
        
        return messages;
    }

    public List<String> readMessagesFromPartition(String topicName, int partition, int messageCount) {
        List<String> messages = new ArrayList<>();
        
        try (Consumer<String, String> consumer = consumerFactory.createConsumer()) {
            TopicPartition topicPartition = new TopicPartition(topicName, partition);
            consumer.assign(Collections.singletonList(topicPartition));
            consumer.seekToBeginning(Collections.singletonList(topicPartition));
            
            while (messages.size() < messageCount) {
                ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
                
                if (records.isEmpty()) {
                    break;
                }
                
                for (ConsumerRecord<String, String> record : records) {
                    if (messages.size() < messageCount) {
                        messages.add(record.value());
                    } else {
                        break;
                    }
                }
            }
        }
        
        return messages;
    }
}


@Configuration
@EnableKafka
public class KafkaConsumerConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public ConsumerFactory<String, String> consumerFactory() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, "direct-reader-group");
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
        return new DefaultKafkaConsumerFactory<>(props);
    }
}
